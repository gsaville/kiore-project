---
title: "Sandbox"
author: "Grace Saville"
date: "01/10/2021"
output: html_document
---
# Preamble 
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r eval = FALSE}
# Installing phylogenetics packages
# install.packages('ctv')
# library('ctv')
# install.views('Phylogenetics')
# update.views('Phylogenetics')
library(plyr)
library(ape)
library(phylotools)
library(stringr)
library(dplyr)
```

## Looking at the data
```{r eval = FALSE}
data <- read.delim("Genotyping-007.010-01_copy2.txt")
dim(data) #478 rows, 332 columns
data[1,1:17] # SNP data in columns 16 to 333
class(data[5,17]) # character
count(data$island) #  how many samples from each island there are
count(data[,206]) # how many of each base combination there are in a SNP column
```

## Making a subset
```{r eval = FALSE}
sub <- data[1:10,17:30] # making subset to experiment with
str(sub)
# sub[sub=="?"] <- NA # not sure if I want to replace the ?'s with NA's
summary(sub)
str(sub)

```

# Heterozygousity experimenting
```{r eval = FALSE}
x <- c("A:A", "G:T", "C:C", "A:T", "T:A","T:T", "A:C", "C:A") # test vector
hetz <- c("A:G", "G:A", "C:T", "T:C", "A:T", "T:A", "C:G", "G:C", "A:C", "C:A", "G:T", "T:G") # vector of heterozygous combinations
homz <- c("G:G", "A:A", "C:C", "T:T") # vector of homozygous combinations

# testing to see if I can identify what values are homozygous and heterozygous within an example vector
for (i in x){
  if (i %in% hetz){print("E")}
  else {print("O")}
}

# testing if I can replace the values in the above example vector 
for (i in 1:length(x)){
  if (x[i] %in% hetz){x[i] <- "E"}
  else {x[i] <- "O"}
}

# trying another method for the subset dataframe:
for (i in 1:nrow(sub)){
  sub[i,][sub[i,] %in% hetz] <- "E"
  sub[i,][sub[i,] %in% homz] <- "O"
}

# applying above for loop to entire df
z <- data # making a copy of the data
for (i in 1:nrow(z)){
  z[i,][z[i,] %in% hetz] <- "E"
  z[i,][z[i,] %in% homz] <- "O"
}

count(z[,105]) #column count
sum(str_count(z[35,], "E")) # row count

# could also try 0 for homo and 1 for hetero, therefore the lower the totals the lower the heterozygousity, however the number of NA's could interfere with the totals
z2 <- data # making a copy of the data
for (i in 1:nrow(z2)){
  z2[i,][z2[i,] %in% hetz] <- 1
  z2[i,][z2[i,] %in% homz] <- 0
}

z2[z2=="?"] <- NA # replacing ? with NA's 
for (i in 16:332) {class(z2[,i]) <- "numeric"} # changed the class to numeric for each column so the totals can be computed (wouldn't work without for loop for some reason?)

z2 <- rowwise(z2) # making the df rowwise so i can make calculations by row easier
names(z2)
z2 <- mutate(z2, total = sum(c_across(X11_CHR1_101004452:X154_CHR9_95290356), na.rm = TRUE))
z2[,333]

# trying this method of adding row totals at the end to the E/O df
z <- rowwise(z)
summarise(z)
mutate(z, Etotal = sum(str_count(z, "E")))
sum(str_count(z[35,], "?")) # row count

```

# Prep for making tree
```{r eval = FALSE}
x <- data.frame(a = c("asdfghjkl1", "asdf2ghjkl", "asdf3ghjkl", "asdfghjkl4"), b = c("CTAGTGACCCGTAG","TGACCCGTTAGAAC", "TGACTCTTTAGAAC", "TTTCACGTTGAGAC")) # dummy df
dat2phylip(x, outfile = "test.phy") # testing this function that saves phylip files
# after some experimenting, spaces in the base strings aren't necessary, but 10 character length names are needed, dashes "-" are allowed, no differentiation between upper and lower case, only letters from bases or amino acids allowed (?, e.g acdefghiklmnprstvwyz)
```
IUPAC Ambiguity code:  

|Symbol|SNP bases|
|:----:|:----:|
|A|AA|
|T|TT|
|C|CC|
|G|GG|
|R (purine)|AG|
|Y (pyrimidine)|CT|
|W (weak)|AT|
|S (strong)|CG|
|M (amino)|AC|
|K (keto)|GT|

```{r eval=FALSE}
y <- data # making a copy
# changing each SNP base combination to a single letter code
# y[y=="?"] <- "-" # "?" also accepted by splitstree
y[y=="A:A"] <- "A"
y[y=="T:T"] <- "T"
y[y=="C:C"] <- "C"
y[y=="G:G"] <- "G"
y[y=="A:G"] <- "R"
y[y=="G:A"] <- "R"
y[y=="C:T"] <- "Y"
y[y=="T:C"] <- "Y"
y[y=="A:T"] <- "W"
y[y=="T:A"] <- "W"
y[y=="C:G"] <- "S"
y[y=="G:C"] <- "S"
y[y=="A:C"] <- "M"
y[y=="C:A"] <- "M"
y[y=="G:T"] <- "K"
y[y=="T:G"] <- "K"

names(y)
y <- y[,-c(2:16)] # removing the rows with information other than the species key and the code above
y <- tidyr::unite(y, bases, -1, sep = "", remove = TRUE) # merging all the base columns into one column so it can be converted easily into a phylip file,
y[,1] <- gsub("NBC.LAB.", "NBCLAB", y[,1]) # replacing part of the name of the rowname column so there is no punctuation and the names are exactly 10 characters long for the phylip file to work

dat2phylip(y, outfile = "test2.phy")
# something wrong with the file, e.g. illegal characters or two of the same specimen
summary(duplicated(y[,1])) # no. 40 row name is duplicated
duplicated(y[,1], fromLast = FALSE)
duplicated(y[,1], fromLast = TRUE) # no. 39 is duplicated w no. 40
summary(duplicated(y)) # checking row 40 doesn't have the same code string as well
y[39:40,1] # "NBCLAB2005" "NBCLAB2005" need to replace one
tail(y[,1], 20) # last specimen is labelled NBCLAB2436, will rename duplicate 2437
y[40,1] <- "NBCLAB2437" # replacing duplicate w new name
summary(duplicated(y[,1])) # double checking
y[,1] # last 8 row names don't have 10 characters: "L0235" "L0234" "C0910" "GMI-4" "P0041" "R14018" "R6750" "R7129"
y[471,1] <- "L023500000" # replacing w new names
y[472,1] <- "L023400000"
y[473,1] <- "C091000000"
y[474,1] <- "GMI0400000"
y[475,1] <- "P004100000"
y[476,1] <- "R140180000"
y[477,1] <- "R675000000"
y[478,1] <- "R712900000"
dat2phylip(y, outfile = "data.phy") # can be opened by splitstree when configured as proteins/amino acids
```
Try writing directly to a .nex file since splitstree only reads the .phy file as protein:
ape::write.nexus.data(x, file, format = "dna")


# Mantel test prep
uses lat/long data, there are geospatial R packages that give exact distances on the globe between lat/long points which will be useful here 
```{r eval=FALSE}
install.packages("ade4") # I think this can be used for the mantel test
# install.packages("geosphere") # calculates distances between 2 points on a sphere
library(ade4)
library(geosphere)

df <- data # make sure rows are samples and columns are variables
#longitude and latitude 
names(df) # need "geo_lat" "geo_long" 

# "need to generate two distance matrices: one containing spatial distances and one containing distances between measured outcomes at the given points.  In the spatial distance matrix, entries for pairs of points that are close together are lower than for pairs of points that are far apart.  In the measured outcome matrix, entries for pairs of locations with similar outcomes are lower than for pairs of points with dissimilar outcomes.  We do this using the dist function.  The Mantel test function will require objects of this “distance” class"
distHaversine() # assumes earth is a sphere
distm() # makes distance matrix
distGeo() # assumes earth is elliptical ish, can choose specific model
geo.dist <- distGeo(cbind(df$geo_long, df$geo_lat)) # do I only need 1 of each location of 1 for every specimen?
geo.dist <- as.matrix(geo.dist)
# sp.dist <- distGeo(df$meandist)
# as.matrix(sp.dist)[1:5, 1:5]

mantel.rtest(sp.dist, geo.dist, nrepet = 9999) # mantel test

```
for later: HKY85 model for distances model
