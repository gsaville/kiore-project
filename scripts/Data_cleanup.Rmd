---
title: "Data_cleanup"
author: "Grace Saville"
date: "11/02/2022"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Preamble 

```{r libraries, eval = FALSE}
library(plyr)
library(reshape)
getwd()
setwd("C:/Users/airhe/OneDrive/Documents/Masters/Project 3/kiore-project")
```

## Loading the data

```{r loading data, eval = FALSE}
data <- read.delim("./data/Genotyping-007.010-01_SNP_Raw_data.tsv")
dim(data) #478 rows (specimens), 333 columns (SNP loci)
data[1,1:17] # SNP data in columns 17 to 333
```

```{r data check, eval = FALSE}
class(data[5,17]) # character
count(data$island.1) #  how many samples from each island there are
data[data$island.1 == "",] # checking why 2 "island.1" cells are blank
data[c(471,473),1:10] # the blanks are from Laos and Cambodia, therefore replacing the blanks with "Mainland"
data[471,"island.1"] <- "Mainland"
data[473,"island.1"] <- "Mainland"

x <- data # keeping "data" as backup original
```

## Tidying SNP order

I'm doing this to make R evaluation easier (e.g when checking for counts it does not count A:G and G:A separately)
```{r SNP arrangement, eval = FALSE}
dim(x) # 333 cols
count(unlist(x[,17:333]))
x[x == "T:A"] <- "A:T"
x[x == "C:A"] <- "A:C"
x[x == "G:A"] <- "A:G" 
x[x == "T:C"] <- "C:T"
x[x == "G:C"] <- "C:G"
x[x == "G:T"] <- "T:G"
count(unlist(x[,17:333])) # checking success
```


### Specimens per Island before data clean-up

```{r eval = FALSE}
count(data$island.1)
```

|Island|freq|
|:----:|:----:|
|Aotea (Great Barrier I)|10|
|Borneo|25|
|Doubtful Sound|1|
|Great Mercury Island|1|
|Halmahera|25|
|Hatutaa|21|
|Honuea|21|
|Kaikura Island|20|
|Kamaka|21|
|Kayangel|21|
|Late Island|21|
|Luzon|1|
|Mainland|5|
|Malenge|25|
|Mohotani|14|
|Motukawanui|21|
|New Britain|26|
|New Guinea|25|
|Normanby Island|25|
|Rakiura (Stewart Isl)|21|
|Reiono|21|
|Rimatuu (Tetiaroa)|21|
|Slipper Island|21|
|Sulawesi|25|
|Tahanea|20|
|Wake Island|20|


## Removing SNP columns with no variation (invariant/monomorphic)

- Should I do this first or last?

```{r invariant removal, eval = FALSE}
# count(x[,20]) # how many of each base combination there are in a SNP column
# length(unique(x[,20])) # how many unique values there are in the column

ncol(x) #333
monocols <- integer() # empty vector for the for loop
for (i in 17:333) {
  z <- length(unique(x[,i])) # no. of unique values in the row (looking for 1, or 2 if there's "?")
    if (z <= 3) 
      {monocols <- append(monocols, i) # if z is as so, add the column number to the vector
    }
  rm(z)
}

monocols # 17  34  73  80  88  95  98 101 102 108 119 129 139 154 156 171 176 177 178 179 194 203 207 208 209 227 237 239 243 251 252 253 265 271 276 324 331
for (i in monocols) {
  print(count(x[,i]))
}
# none with only 1 unique SNP in each column ...? It's possible since the SNP loci were selected for their differences, but double check this 

# x <- x[,-c(monocols)]

rm(i, monocols)
```

## Removing columns (SNPs) with few samples

```{r removing sparse columns, eval = FALSE}
# count(x[,34]) # how many of each base combination there are in a SNP column
# count(grepl("?", x[,33], fixed = TRUE)) # True means "?"


ncol(x) #333
percblank <- integer() # empty df for the for loop
for (i in 17:333) {
  y <- count(grepl("?", x[,i], fixed = TRUE)) # finds and counts freq of ?
  z <- signif((nrow(x)- y[1,2])/nrow(x)*100, 4) # percentage of ? in the column, to 4 signif digits. I used the no. rows-false outcomes instead of the true outcomes because some rows have no ?s and result in errors.
    if (z > 60) 
      {percblank <- append(percblank, i) # if z (% of ?) is as so, add the column number to the vector
    }
  rm(z)
  rm(y)
}

percblank # 17  18  19  25  48  65  69  73  80  88  89  96 102 108 131 133 146 147 156 159 162 165 179 185 205 208 212 228 241 258 264 265 271 304 330
# checking:
# count(x[,271])
# 444/478

x <- x[,-c(percblank)]
ncol(x) #298

rm(i, percblank)
```

## Removing rows (specimens) with few samples

```{r removing sparse rows, eval = FALSE}
x2 <- data.table::transpose(x) # transposing the df temporarily since count() doesn't work well on rows
# count(x2[17:298,1]) # how many of each base combination there are in a specimen row
# count(grepl("?", x2[,50], fixed = TRUE)) # True means "?" number

ncol(x2) #478 specimens
percblank <- integer() # empty df for the for loop
for (i in 1:478) {
  y <- count(grepl("?", x2[,i], fixed = TRUE)) # finds and counts freq of "?"
  z <- signif((nrow(x2)- y[1,2])/nrow(x2)*100, 4) # percentage of "?" in the specimen, to 4 signif digits. I used the no. rows-false outcomes instead of the true outcomes because some rows have no "?" and result in errors.
    if (z > 56) 
      {percblank <- append(percblank, i) # if z (% of "?") is as so, add the column number to the vector
    }
  rm(z)
  rm(y)
}

percblank # 1   7   9  10  11  18  25  48  49  50  51  52  53  55  56  57  58  59  60  62  63  65  66  71  79 80  87  88  89  90  91  92  93  95  96  97 101 102 103 104 105 106 108 109 110 111 112 113 114 115 117 118 119 120 121 122 123 124 125 128 129 131 133 134 135 136 137 139 141 142 143 144 145 146 150 151 152 153 154 155 156 157 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 335
# checking work:
# count(x2[17:298,171])
# 185/298

x <- x[-c(percblank),] # removing the rows listed (percblank) that have too many "?" from the df
nrow(x) #377

# checking the % of all ? in the df:
z <- count(grepl("?", unlist(x), fixed = TRUE))
signif(z[2,2]/(z[1,2]+z[2,2])*100, 4) # 9.723% "?"
100 - 9.723 # 90.277% complete df, ideal point where there is more than 90% completeness but not too many rows and columns removed (yet)

rm(i, percblank, x2, z)
getwd()
save(list=ls(all=TRUE), file="Data_cleanup.RData") # save RDATA for later use
```

## Prepping df for HWE Analysis

I would like to remove the SNPs not in Hardy-Weinberg equilibrium, therefore I need to reformat the data for input into HWE function.

```{r}
load("Data_cleanup.RData") # if necessary
```

```{r data prep, eval = FALSE}
x2 <- x # making a copy
x2[1,1:20] # checking column names
x2 <- x2[,-c(2:16)] # removing all but specimen names and SNPs
x2[1,1:20] # checking

x2[x2 == "?"] <- "?:?" # replacing single ? with double ? so alleles can be split

x3 <- data.frame(island = x2$island) # setting up new df for for loop
coln <- as.vector(colnames(x2)) # prepping to paste the column names into the for loop
dim(x2) # 379 rows 283 columns
for (i in 2:283) {
  y <- colsplit(x2[,i], split = ":", names = c(coln[i], paste("blank", i, sep = "."))) # splitting each i column and renaming them 
  x3 <- cbind(x3, y) # combining output with current df
  rm(i, y) # removing temp objects
}

# Checking:
dim(x3) # 379 rows 565 columns
x2[1:5,1:5] 
x3[1:5,1:5] # comparing the 2 dfs to check the column naming worked correctly

x2 <- x3
rm(x3, coln) # removing excess objects
```

The following chunk is for for producing the file necessary for PGDSpider program:

```{r data prep 2, eval = FALSE}
x2 <- x2[order(x2$island, decreasing = FALSE),] # ordering df alphabetically by island
print(as.matrix(x2[,1])) # printing the island names and row numbers 

# A=1, T=2, G=3, C=4
x2[x2 == "A"] <- "1"
x2[x2 == "T"] <- "2"
x2[x2 == "G"] <- "3"
x2[x2 == "C"] <- "4"

popnames <- as.character(c( # row numbers in dataset df listed below for each popn.
  "pop = Aotea", # 1:10
  "pop = Borneo", # 11:28
  "pop = Doubtful_Sound", # 315
  "pop = Great_Mercury_Island", # 30
  "pop = Halmahera", # 31:42
  "pop = Hatutaa", # 43:63
  "pop = Honuea", # 64:83
  "pop = Kaikura_Island", # 84:103
  "pop = Kamaka", # 104:124
  "pop = Kayangel", # 125:145
  "pop = Late_Island", # 148:168
  "pop = Mainland", # 29, 146, 147, 169, 358, 359
  "pop = Malenge", # 170:181
  "pop = Mohotani", # 182:195
  "pop = Motukawanui", # 196:216
  "pop = New_Britain", # 217:226
  "pop = New_Guinea", # 227:229
  "pop = Normanby_Island", # 230
  "pop = Rakiura", # 231:251
  "pop = Reiono", # 252:272
  "pop = Rimatuu", # 273:293
  "pop = Slipper_Island", # 294:314
  "pop = Sulawesi", # 316:337
  "pop = Tahanea", # 338:357
  "pop = Wake_Island" # 360:379
))

# Creating population dfs
a <- as.data.frame(x2[1:10,]) # Aotea
b <- as.data.frame(x2[11:28,]) # Borneo
c <- as.data.frame(x2[315,]) # Doubtful_Sound
d <- as.data.frame(x2[30,]) # Great_Mercury_Island
e <- as.data.frame(x2[31:42,]) # Halmahera
f <- as.data.frame(x2[43:63,]) # Hatutaa
g <- as.data.frame(x2[64:83,]) # Honuea
h <- as.data.frame(x2[84:103,]) # Kaikura_Island
i <- as.data.frame(x2[104:124,]) # Kamaka
j <- as.data.frame(x2[125:145,])  # Kayangel
k <- as.data.frame(x2[148:168,]) # Late_Island
l <- as.data.frame(x2[c(29, 146, 147, 169, 358, 359),]) # Mainland 
m <- as.data.frame(x2[170:181,]) # Malenge
n <- as.data.frame(x2[182:195,]) # Mohotani 
o <- as.data.frame(x2[196:216,]) #  Motukawanui
p <- as.data.frame(x2[217:226,]) #  New_Britain
q <- as.data.frame(x2[227:229,]) # New_Guinea 
r <- as.data.frame(x2[230,]) #  Normanby_Island
s <- as.data.frame(x2[231:251,]) # Rakiura
t <- as.data.frame(x2[252:272,]) # Reiono
u <- as.data.frame(x2[273:293,]) # Rimatuu 
v <- as.data.frame(x2[294:314,]) # Slipper_Island
w <- as.data.frame(x2[316:337,]) #  Sulawesi 
# x
y <- as.data.frame(x2[338:357,]) # Tahanea
z <- as.data.frame(x2[360:379,]) # Wake_Island

pops <- as.character(c(letters[seq(from = 1, to = 23)], "y", "z")) # list of popn object names

# x3 <- list("title", "npops = 25", "nloci = 282") # creating list of values to be exported
# for (ii in 1:25) {
#  x3 <- rlist::list.append(x3, popnames[ii])
#  x3 <- rlist::list.append(x3, get(pops[ii]))
#  rm(ii)
} # appending the popn names and dfs to the list


# Saving the list to file
getwd()
# sink("ratsSNPs_PGDSpyder_input.csv") # create empty file

ncol(x2)

sink("test.txt")
cat("rats_SNPS", "npops = 25", "nloci = 282", fill = 1)
cat(colnames(x2[-1]), "\n", sep = "\t\t", fill = FALSE) # column/SNP names
cat(popnames[1], fill = 1)
for (i1 in 1:length(pops)) { # outer loop
  i1 <- pops[i1]
  for (i2 in 1:nrow(i1)) { # inner loop
    print(cat(as.character(i1[i2,]), fill = FALSE, sep = "\t"))
  } # inner loop close
} # outer loop close
sink()



for (i1 in 1:25) { # outer loop
  print(cat(popnames[i1], fill = 1)
  foo <- 
  for (i2 in 1:length(i1) { # inner loop
    print(cat(as.character(i1[i2,]), fill = FALSE, sep = "\t") # Aotea
  } # inner loop close
} # outer loop close






length(x3)
for (ii in 1:3) {
  cat(x2[[11]], fill = TRUE)
} # printing in console the text to send to the file
sink() # closing the sink connection to the file 

rm(ii, letters[seq(from = 1, to = 23)], y, z)

# write.csv(x3, "ratsSNPs_PGDSpyder_input.csv", row.names = FALSE)
```

The CONVERT format is defined as follows:
• It is an EXCEL file saved as a tab delimited Text file (*.txt)
• The first line (cell A1) contains a brief description of the data file (title)
• The second line (cell A2) gives the number of populations present in the data file (e.g.: npops
= 2)
• The third line (cell A3) contains the number of loci (e.g.: nloci = 7)
• fourth line: the names of the loci (in order, without spaces, underscores are allowed)
• Each population starts with the line pop = pop_name. There must be at least one space
between 'pop' and '='. Spaces within population name are not allowed, but an underscores
can be used.
• Each individual within a population begins with an individual name. It can be a number,
characters like: '/', '=', '?', ':', ';' or ',' are not allowed and there must be no spaces within
names.
• After an individual’s name, the diploid genotypes are given:
o on the same line or wrapped to the next line
o alleles must be given in numeric form (two alleles for each locus)
o alleles can be coded as any integer between 1 and 9999
o Typically the numbers will indicate the size of the allele in base pairs (e.g., for
microsats)
o Missing data are coded as: '?






check which specimens will be in the mainland popn. (e.g. luzon, also Borneo and Sulawesi), and if populations w 1 specimen are vialble (e.g. doubtful sound and great mercury isl.)

Structure input file creation (PGD Spider)
INFO  19:18:54 - Convert...
INFO  19:19:50 - convert CONVERT:outputtest.txt to STRUCTURE:STRUCTUREinput
WARN  19:19:50 - Data are converted to integers (A=1, T=2, G=3, C=4)!
WARN  19:19:51 - Data in individual "Southland1" does not have the requested ploidy (diploid). Missing alleles will be coded as missing data!
INFO  19:19:51 - translation completed

why are there two of each row in the files from PGD Spider? Should I select DNA instead of SNP?

arlequin: made general setting missing level per site 0.25

## HWE Analysis and removal

## Prep for Structure Analysis

## Structure Analysis and removal 



To do:

- cleanup: remove SNPs not in HW equilibrium
- cleanup: remove samples that are weird in the structure analysis
- cleanup: double check for monomorphic columns
- re-run NeighborNet and Mantel test
- aggregate samples at island level, calculate island-to-island Fst and/or Nei distance
- calculate heterozygosity, should decrease with distance, possibly be shaped by island size
- PCA on the SNPs
